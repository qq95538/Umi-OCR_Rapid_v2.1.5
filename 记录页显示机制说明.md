# Umi-OCR "记录"页显示每页识别结果的实现机制

## 一、概述

"记录"页用于显示批量文档OCR识别过程中每一页的识别结果。本文档详细说明了从Python后端OCR识别到QML前端显示的完整数据流。

## 二、架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                      数据流架构图                              │
└─────────────────────────────────────────────────────────────┘

用户操作 (点击"开始")
    ↓
BatchDOC.qml (QML前端)
    ↓ callPy("msnDocs", docs, argd)
BatchDOC.py (Python控制器)
    ↓ MissionDOC.addMission()
MissionDOC (Python任务管理器)
    ↓ 每页处理完成后调用
BatchDOC._onGet() (回调函数)
    ↓ callQmlInMain("onDocGet", path, page, res)
BatchDOC.qml.onDocGet() (QML回调)
    ↓ resultsTableView.addOcrResult(res)
ResultsTableView.qml (显示组件)
    ↓ 结果添加到ListModel
ListView/TableView (自动更新UI)
    ↓
用户看到每页识别结果
```

## 三、核心组件详解

### 3.1 ResultsTableView组件

**文件位置**: `UmiOCR-data/qt_res/qml/Widgets/ResultLayout/ResultsTableView.qml`

**核心功能**:
1. 维护OCR结果的ListModel
2. 提供`addOcrResult()`接口添加结果
3. 使用TableView显示所有记录
4. 支持文本选择、复制、删除等操作

**关键字段**:
```qml
ListModel { id: resultsModel }  // OCR结果模型

function addOcrResult(res) {
    // 1. 提取时间戳并格式化
    let date = new Date(res.timestamp * 1000)
    let dateTimeString = `${hours}:${minutes}`
    
    // 2. 根据状态码处理结果
    switch(res.code){
        case 100: // 成功
            status_ = "text"
            resText = 提取文本内容
            break
        case 101: // 无文字
            status_ = "noText"
            break
        default: // 失败
            status_ = "error"
            resText = 错误信息
            break
    }
    
    // 3. 添加到ListModel
    resultsModel.append({
        "status__": status_,
        "title": res.title,
        "datetime": dateTimeString,
        "resText": resText,
        "timestamp": res.timestamp,
        "selectL_": -1,
        "selectR_": -1,
        "selectUpdate_": 0,
        "source": JSON.stringify(res)
    })
    
    // 4. 自动滚动到底部
    if(autoToBottom) {
        tableView.toBottom()
    }
    
    return resText
}
```

### 3.2 BatchDOC.qml (QML前端)

**文件位置**: `UmiOCR-data/qt_res/qml/TabPages/BatchDOC/BatchDOC.qml`

**核心函数 - onDocGet**: 接收单页OCR结果并显示

```qml
// 获取一个文档的一页的结果
function onDocGet(path, page, res) {
    // 1. 刷新单个文档的状态显示
    const d = filesTableView.get(path)
    const state = `${page - d.range_start + 1}/${d.range_end - d.range_start + 1}`
    filesTableView.setProperty(path, "state", state)
    
    // 2. 提取文字，添加到结果表格
    const title = path2name(path)
    res.title = `${title} - ${page}`  // 设置标题格式：文件名 - 页码
    resultsTableView.addOcrResult(res)  // 添加到记录页
    
    // 3. 更新进度
    ctrlPanel.msnStep(1)
}
```

### 3.3 BatchDOC.py (Python控制器)

**文件位置**: `UmiOCR-data/py_src/tag_pages/BatchDOC.py`

**核心函数 - _onGet**: 处理单页OCR结果并通知QML

```python
def _onGet(self, msnInfo, page, res):
    """一个文档的一页 获取结果"""
    page += 1  # 转为1开始的页码
    msnID = msnInfo["msnID"]
    if not msnID == self._msnID:
        logger.warning(f"_onGet 任务ID未在记录。{msnID}")
        return

    # 1. 为 res 添加信息
    res["page"] = page
    res["fileName"] = f"{page}"
    res["path"] = msnInfo["path"]

    # 2. 输出到文件（txt、jsonl、pdf等）
    for o in msnInfo["get_output"]:
        try:
            o.print(res)
        except Exception:
            logger.error(f"文档结果输出失败：{o}", exc_info=True, stack_info=True)

    # 3. 通知QML更新UI
    self.callQmlInMain("onDocGet", msnInfo["path"], page, res)
```

### 3.4 mission_doc.py (OCR任务管理器)

**文件位置**: `UmiOCR-data/py_src/mission/mission_doc.py`

**核心函数 - msnTask**: 执行单页OCR识别

```python
def msnTask(self, msnInfo, pno):
    """执行msn。pno为当前页数"""
    doc = msnInfo["doc"]
    page = doc[pno]
    argd = msnInfo["argd"]
    extractionMode = argd["doc.extractionMode"]
    
    # 1. 提取图片和原文本
    imgs = []  # 待OCR的图片列表
    tbs = []   # 文本块列表
    
    # 2. 根据提取模式处理
    if extractionMode == "fullPage":  # 整页强制OCR
        # 渲染整页为图片
        p = page.get_pixmap(matrix=matrix)
        bytes = p.tobytes("png")
        imgs.append({"bytes": bytes, ...})
    else:  # 混合模式
        # 提取文本和图片
        p = page.get_text("dict", clip=fitz.INFINITE_RECT())
        for t in p["blocks"]:
            if t["type"] == 1:  # 图片
                imgs.append(...)
            elif t["type"] == 0:  # 文本
                tbs.append(...)
    
    # 3. 调用OCR
    if imgs:
        ocrArgd = {k: argd[k] for k in argd if k.startswith("ocr.")}
        ocrList = MissionOCR.addMissionWait(ocrArgd, imgs)
        
        # 4. 整理OCR结果
        for o in ocrList:
            res = o["result"]
            if res["code"] == 100:
                for r in res["data"]:
                    r["from"] = "ocr"
                    tbs.append(r)
    
    # 5. 组装结果字典
    if tbs:
        resDict = {"code": 100, "data": tbs}
    elif errMsg:
        resDict = {"code": 102, "data": errMsg}
    else:
        resDict = {"code": 101, "data": ""}
    
    return resDict
```

## 四、完整数据流程

### 4.1 启动流程

```
1. 用户点击"开始"按钮
   ↓
2. BatchDOC.qml.docStart()
   ↓
3. 获取所有文档信息
   ↓
4. 切换到"记录"页 (tabPanel.currentIndex = 1)
   ↓
5. 调用 tabPage.callPy("msnDocs", docs, argd)
   ↓
6. BatchDOC.py.msnDocs() 被调用
```

### 4.2 单页处理流程

```
BatchDOC.py.msnDocs()
   ↓
创建任务信息字典 msnInfo = {
    "onStart": self._onStart,
    "onGet": self._onGet,
    "onEnd": self._onEnd,
    "argd": docArgd,
    ...
}
   ↓
提交到任务管理器: MissionDOC.addMission(msnInfo, path, pageRange)
   ↓
任务管理器启动异步工作线程
   ↓
开始处理第一页
   ↓
调用 _onStart(path) → QML.onDocStart(path)
   ↓
调用 mission_doc.msnTask(msnInfo, pageNo)
   ↓
   ├─ 提取页面图片/文本
   ├─ 调用OCR引擎识别
   ├─ 处理识别结果
   └─ 返回结果字典 res
   ↓
调用 _onGet(page, res) → QML.onDocGet(path, page, res)
   ↓
   ├─ 保存结果到文件 (txt/jsonl/pdf等)
   └─ 调用 resultsTableView.addOcrResult(res)
       ↓
       ├─ 格式化时间戳
       ├─ 根据状态码处理结果
       ├─ 添加到 ListModel
       └─ 自动滚动到底部
   ↓
继续处理下一页...
```

### 4.3 完成流程

```
所有页面处理完毕
   ↓
调用 _onEnd(msg, isAll) → QML.onDocEnd(path, msg, isAll)
   ↓
   ├─ 关闭输出器，保存文件
   ├─ 更新文档状态为 "√"
   └─ 如果是全部完成：
       ├─ 显示"批量识别完成"提示
       ├─ 停止进度条
       └─ 清理任务状态
```

## 五、数据结构

### 5.1 Python传递给QML的结果字典 (res)

```python
res = {
    "code": 100,              # 状态码：100=成功, 101=无文字, 102/其他=错误
    "data": [                # 文本块列表
        {
            "box": [[x0,y0], [x1,y0], [x1,y1], [x0,y1]],  # 坐标框
            "text": "识别的文字",                           # 文本内容
            "score": 0.98,                                  # 置信度
            "end": "\n",                                   # 行尾分隔符
            "from": "ocr"                                  # 来源：ocr/text
        },
        ...
    ],
    "time": 1.23,             # 耗时（秒）
    "timestamp": 1234567890,  # Unix时间戳
    "page": 1,                # 页码
    "path": "/path/to/file",  # 文件路径
    "fileName": "1"           # 文件名（页码）
}
```

### 5.2 QML ListModel中的记录项

```javascript
{
    "status__": "text",           # 状态：text/noText/error
    "title": "document.pdf - 1",   # 标题（文件名-页码）
    "datetime": "12:30",          # 时间
    "resText": "识别的完整文本...", # 完整文本
    "timestamp": 1234567890,       # 时间戳
    "selectL_": -1,               # 选区起始位置
    "selectR_": -1,               # 选区结束位置
    "selectUpdate_": 0,           # 选区更新计数
    "source": "{\"code\":100,...}" # 原始JSON数据
}
```

## 六、关键机制说明

### 6.1 Python-QML通信机制

**双向调用**:
1. **QML → Python**: `callPy(controllerKey, method, args)`
   - 通过 `MissionConnector.callPy()` 实现
   - 同步调用，直接获取返回值

2. **Python → QML**: `callQmlInMain(method, *args)`
   - 通过 `Page.callQmlInMain()` 实现
   - 在主线程中执行，避免UI卡死
   - 用于更新UI状态

### 6.2 异步任务机制

**工作原理**:
1. 任务管理器使用单独的工作线程执行OCR
2. 通过回调函数（onStart/onGet/onEnd）通知QML
3. `callQmlInMain`确保回调在主线程执行
4. 避免长时间阻塞UI线程

### 6.3 页面状态管理

**任务队列**:
- `_msnID`: 当前正在处理的任务ID
- `_queuedDocs`: 排队等待处理的文档列表
- `_pauseMsnID`: 暂停的任务ID

**状态转换**:
```
waiting → running → stop/pause → (结束)
  ↓         ↓
ready     onGet
```

### 6.4 自动滚动机制

**实现原理**:
```qml
Timer {
    id: bottomTimer
    interval: 100
    repeat: true
    onTriggered: {
        // 检查是否已到底部
        if(scrollBar.position >= (1 - scrollBar.size)) {
            bottomTimer.running = false
        } else {
            // 未到底部，继续拉到底部
            scrollBar.position = (1 - scrollBar.size)
        }
    }
}

function toBottom() {
    bottomTimer.running = true
}
```

## 七、关键文件清单

| 文件路径 | 作用 |
|---------|------|
| `UmiOCR-data/qt_res/qml/Widgets/ResultLayout/ResultsTableView.qml` | "记录"页显示组件 |
| `UmiOCR-data/qt_res/qml/TabPages/BatchDOC/BatchDOC.qml` | 批量文档QML前端 |
| `UmiOCR-data/py_src/tag_pages/BatchDOC.py` | 批量文档Python控制器 |
| `UmiOCR-data/py_src/mission/mission_doc.py` | 文档OCR任务管理器 |
| `UmiOCR-data/py_src/mission/mission.py` | 任务管理器基类 |
| `UmiOCR-data/py_src/mission/mission_connector.py` | Python-QML连接器 |
| `UmiOCR-data/py_src/tag_pages/page.py` | 页面控制器基类 |

## 八、与TIFF功能的关系

对于TIFF文件的处理，上述流程**完全适用**：

1. **文件识别**: 通过`.tiff`/`.tif`扩展名识别为文档
2. **页面处理**: fitz库自动处理多页TIFF
3. **OCR识别**: 与PDF处理完全相同
4. **结果显示**: 使用相同的ResultsTableView组件
5. **唯一区别**: 输入文件格式不同，后续流程一致

## 九、总结

"记录"页显示机制的实现特点：

1. **分层架构**: Python后端处理 → Python控制器 → QML前端 → UI组件
2. **异步处理**: OCR识别在后台线程执行，不阻塞UI
3. **实时更新**: 每页处理完成立即显示，用户可实时查看进度
4. **数据封装**: 通过标准化的res字典传递数据
5. **灵活性**: 支持多种文档格式（PDF、TIFF等）
6. **可扩展**: 易于添加新的输出格式和显示功能

这种设计模式使得TIFF等新格式的支持非常简单，只需在文件类型识别层面添加支持即可，后续处理流程无需修改。